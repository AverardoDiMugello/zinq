# Architecture

## Problems

1. **Over-coupling data to the processor:** Because of the processor's role in driving so much of the emulation, all data in the program ends up being over-coupled to the ProcCtx that provides the interface for a processor model to execute instructions, handle interrupts, and translate addresses. Reads to both registers and memory need to complete immediately, so the ProcCtx has to borrow the data needed to service those operations. Because both registers and memory can be mapped to devices, the ProcCtx must mutably borrow not just the register data that intuitively "belongs" to the processor model but also must have a mutable borrow of all devices and the memory map, since reads to device-mapped registers and memory can both trigger mutations in the underlying devices. Additionally, because register and memory accesses can be instrumented, the ProcCtx needs a mutable borrow of all instrumentation objects to deliver the instrumentation as those accesses happen. This limits the power of the instrumentation APIs. If the instrumentation context wants to borrow

2. **Static unit types for the Register API hasn't turned out right:** Registers are identified by unit types with static associated constants for their size and name. These types are declared to the runtime which generates a bitvec to hold all of the declared register data and a HashMap of the register TypeIds to the register's corresponding data in the bitvec. The benefit of this design is that it allows compile-time validation that registers have the appropriate size and length for a given context. The specific contexts this is used in are guaranteeing non-zero-length registers at declaration, guaranteeing less-than-or-equal-to 64-bit registers in the ProcCtx/Data read/write APIs, and guaranteeing valid inputs to the IR register handle API. This design has a number of trade-offs, however. Originally, I thought that this could allow ergonomic register read/write APIs through type inference, e.g.`proc.read::<RegisterName>()`. However, if you want variable output types for this API, you need a second type paramater in the function signature, and Rust requires if you specify one type parameter in the turbo-fish, all must be specified. The example becomes `proc.read::<RegisterName, u64>()` or `proc.read::<RegisterName, bool>()` or at best `proc.read::<RegisterName, _>()` which is still ugly. When only one output type is permitted, currently u64, all 1 bit registers need to be accessed as `proc.read::<RegisterName>() != 0` to be used as bools in subsequent Rust code. Any register of greater size than 64-bits needs a separate API function, currently `proc.read_ext::<RegisterName>()`. Furthermore, while I had hoped to make a trait to allow custom types like ARM's EL or BType enums to be used in these register access APIs, no good solution for that has emerged yet. Instead, these custom register-type APIs are offloaded to the ARM-specific ProcCtx wrapper type (more on that in the next paragraph). Insofar as performance can be meaningfully assesed at this stage, the current implementation of this design appears to be lacking in this regard as well. Flamegraph analysis of the Linux boot example shows register reads as a major bottleneck, with the hash lookup that maps TypeId to offsets in the register data bitvec as a particular culprit (_todo: reference appendix_). No distinction is made yet between general-purpose registers and system registers, despite the very different ways in which these are used, or even just "commonly-used" registers and "rarely-used" registers. A subset of system registers are used at every memory access for address translation, and slow access to them is currently the biggest performance bottleneck. All architectures I expect Zinq to support will almost certainly have this same property as ARM where a tiny minority of registers represent the overwhelming majority of accesses, so it is reasonable for the architecture to suport some way to account for this.

3. **Processor vs ProcCtx distinction is awkward:** Zinq must support users instrumenting the processor model's interaction with its registers as it fetches and executes instructions, handles interrupts, and translates addresses. The full-scope of registers, general-purpose and system, must be supported by the instrumentation model. To support this, Zinq has the processor model declare register state to the runtime, and the runtime initializes and owns the corresponding register data in a bitvec in the ProcData struct. The processor model implements the logic for instruction fetch/decode, interrupt handling, and address translation via the ProcCtx struct. The ProcCtx wraps a mutable borrow of ProcData's register bitvec while providing an API to access registers. This allows the runtime to mediate all accesses to the register data and insert instrumentation in-between. The ProcCtx acts more generally as the processor model's interface for "anything that the runtime owns," providing APIs for memory access, TLB access, the counter, and a random-number generator. The struct that represents the "processor model" ends up just representing a static config of the processor. In the case of the ARM model, the ArmCpu struct contains just the versions, features, and implementation-defined configuration of the processor. The only public methods it provides are convenience methods to updatate this configuration. This struct is the one that actually implements the Processor trait whose methods the runtime uses to drive emulation. Each one of these methods takes for a parameter a mutable borrow of the ProcCtx. The processor model then defines all helper methods for executing the logic of emulation on a type that wraps both the static config and the mutable borrow of the ProcCtx, in ARM's case the ArmCtx struct. The helper methods pretty closely mirror the ARM Sail model but with some awkward semantics resulting from the three lifetimes invloved (the reference to ArmCpu, the reference to ArmCtx, and the reference to the data ArmCtx references). It feels weird for the processor to not own its registers, and the arch-specific wrapper doesn't feel like a good solution.

4. **Memory API shortcomings:** Right now the memory API doesn't support passing a reference to a slice of memory to consumers. While this has been the API in most iterations of the Zinq architecutre, it became a problem when the complexity of lifetime management exploded with the ProcCtx getting a mutable borrow to nearly everything in the program. The current patch-work solution is to have memory consumers receive a byte array equal in size to the largest currently-needed memory request (16 bytes). This is not only awkward for the processor ld/st but won't survive the addition of DMA. Additionally, there isn't really an intuitive way to express device-to-device memory access. There also isn't a good distinction between buffer-backed memory and device-backed memory. This creates borrowing difficulties since buffers don't need to be mutably borrowed for reads, while devices do.

## Appendix

_TODO: insert flamegraphs_
